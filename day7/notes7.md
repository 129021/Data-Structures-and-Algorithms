# 1. 大O表示法
在数据项个数发生改变时，算法的效率会跟着发生改变
所以我们通常使用一种算法的速度会跟着数据量变化而变化的表示方法

## 1.1. 常见的大O表示形式
- O(1):常数级
- O(log(n)):对数级
- O(n):线性的
- O(nlog(n)):线性和对数乘积
- O(n^2)：平方
- o(2^n):指数级

推导大O表示法的方式：
- 用常量1取代运行时间中所有的加法常量
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高存在且不为1，则去除与这个项相乘的常数

# 2. 排序算法
## 2.1. 认识排序算法
排序算法非常多：
- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 计数排序
- 基数排序
- 希尔排序
- 堆排序
- 桶排序
- ...

在这里不一一列举实现思想，选择几个简单排序和高级排序介绍：
- 简单排序
  - 冒泡排序
  - 选择排序
  - 插入排序
- 高级排序
  - 希尔排序
  - 快速排序

## 2.2. 封装列表
在开始排序前，我们先来创建一个列表封装我们的数据项
```js
// 创建列表类
function ArrayList() {
    //属性
    this.array = []

    //方法

    // 将数组可以插入到数组中的方法
    ArrayList.prototype.insert = function (item) {
        this.array.push(item)
    }

    // toString方法
    ArrayList.prototype.toString=function(){
        return this.array.join('-')
    }
}
```
## 2.3. 冒泡排序
冒泡排序的思路：
- 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
- 如果左边的队员高，则两队员交换位置
- 向右移动一个位置，比较下面两个队员
- 当走到最右端时，最高的队员一定被放在了最右边
- 按照这个思路，从最左端重新开始，这次走到倒数第二个位置的队员即可
- 以此类推，就可以将数据排序完成


### 2.3.1. 代码实现
```js
// 冒泡排序
ArrayList.prototype.bubblesort = function () {
    // 1. 获取数组的长度
    var length = this.array.length
    // 第一次：j=length-1，比较到倒数第一个位置
    // 第二次：j=length-2，比较到倒数第2个位置
    // 以此类推
    for (var j = length - 1; j >= 0; j--) {
        for (var i = 0; i < j; i++) {
            // 第一次进来：i=0,比较0和1位置的两个数据，如果0位置上的数据比较大，交换两个数据的位置
            if (this.array[i] > this.array[i + 1]) {
                //交换两个数据的位置
                // var temp = this.array[i]
                // this.array[i] = this.array[i + 1]
                // this.array[i + 1] = tmep
                this.swap(i, i + 1)
            }
        }
    }
}
```
### 2.3.2. 冒泡排序的效率

- 冒泡排序的比较次数：
  - 对于N个数据项的比较次数：(N-1)+(N-2)+(N-3)+...+1=N*(N-1)/2
  - 所以冒泡排序比较次数的大O表示法为O(N^2)
- 冒泡排序的交换次数：
  - 如果有两次比较才需要交换一次（不可能每次比较都交换一次），那么交换次数为N^2/4
  - 由于常量不算在大O表示法中，因此，我们可以认为交换次数的大O表示也是O(N^2)

## 2.4. 选择排序
选择排序改进了冒泡排序：
- 将交换的次数有O(N^2)减少到了O(N)
- 但是比较的次数依然是O(N^2)

选择排序的思路：
1. 选定第一个索引位置，然后和后面元素依次比较
2. 如果后面的队员小于第一个索引位置的队员，则交换位置
3. 经过一轮的比较后，可以确定第一个位置是最小的
4. 然后使用同样的方法把剩下的元素逐个比较即可
5. 可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后


