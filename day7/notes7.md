# 1. 大O表示法
在数据项个数发生改变时，算法的效率会跟着发生改变
所以我们通常使用一种算法的速度会跟着数据量变化而变化的表示方法

## 1.1. 常见的大O表示形式
- O(1):常数级
- O(log(n)):对数级
- O(n):线性的
- O(nlog(n)):线性和对数乘积
- O(n^2)：平方
- o(2^n):指数级

推导大O表示法的方式：
- 用常量1取代运行时间中所有的加法常量
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高存在且不为1，则去除与这个项相乘的常数

# 2. 排序算法
## 2.1. 认识排序算法
排序算法非常多：
- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 计数排序
- 基数排序
- 希尔排序
- 堆排序
- 桶排序
- ...

在这里不一一列举实现思想，选择几个简单排序和高级排序介绍：
- 简单排序
  - 冒泡排序
  - 选择排序
  - 插入排序
- 高级排序
  - 希尔排序
  - 快速排序

## 2.2. 封装列表
在开始排序前，我们先来创建一个列表封装我们的数据项
```js
// 创建列表类
function ArrayList() {
    //属性
    this.array = []

    //方法

    // 将数组可以插入到数组中的方法
    ArrayList.prototype.insert = function (item) {
        this.array.push(item)
    }

    // toString方法
    ArrayList.prototype.toString=function(){
        return this.array.join('-')
    }
}
```
## 2.3. 冒泡排序
冒泡排序的思路：
- 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
- 如果左边的队员高，则两队员交换位置
- 向右移动一个位置，比较下面两个队员
- 当走到最右端时，最高的队员一定被放在了最右边
- 按照这个思路，从最左端重新开始，这次走到倒数第二个位置的队员即可
- 以此类推，就可以将数据排序完成

